create extension if not exists "pgjwt" with schema "extensions";


create extension if not exists "btree_gist" with schema "public" version '1.7';

create sequence "public"."reservations_id_seq";

create sequence "public"."washing_machines_id_seq";

create table "public"."base_users" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text not null,
    "surname" text,
    "auth" uuid,
    "resident" bigint
);


alter table "public"."base_users" enable row level security;

create table "public"."customers" (
    "id" bigint generated by default as identity not null,
    "fullname" text not null,
    "user_link" uuid,
    "created_at" timestamp with time zone default now()
);


create table "public"."gerba_storage" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "minister" uuid not null default auth.uid(),
    "beer_count" bigint not null,
    "price" numeric(10,2) not null,
    "notes" text
);


create table "public"."items" (
    "created_at" timestamp with time zone not null default now(),
    "name" text not null,
    "price" numeric not null,
    "beer_count" bigint not null,
    "id" uuid not null default gen_random_uuid(),
    "visible" boolean not null default true
);


create table "public"."permission_types" (
    "id" bigint generated by default as identity not null,
    "name" text not null,
    "display_name" text not null default ''::text
);


alter table "public"."permission_types" enable row level security;

create table "public"."permissions" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" bigint,
    "permission_type" bigint,
    "permission_creator" bigint
);


alter table "public"."permissions" enable row level security;

create table "public"."reservations" (
    "id" bigint not null default nextval('reservations_id_seq'::regclass),
    "machine_id" integer not null,
    "slot" tstzrange not null,
    "created_at" timestamp with time zone default now(),
    "note" text,
    "user_id" bigint
);


create table "public"."residents" (
    "id" bigint generated by default as identity not null,
    "room" bigint not null,
    "birth_date" timestamp with time zone,
    "created_at" timestamp with time zone not null default now(),
    "phone_number" text
);


alter table "public"."residents" enable row level security;

create table "public"."transactions" (
    "id" bigint generated by default as identity not null,
    "customer_id" bigint not null,
    "ordered_at" timestamp with time zone not null default now(),
    "ordered" bigint not null default '0'::bigint,
    "paid" bigint not null,
    "minister" uuid not null,
    "item" uuid
);


create table "public"."washing_machines" (
    "id" integer not null default nextval('washing_machines_id_seq'::regclass),
    "name" text not null,
    "description" text
);


alter table "public"."washing_machines" enable row level security;

alter sequence "public"."reservations_id_seq" owned by "public"."reservations"."id";

alter sequence "public"."washing_machines_id_seq" owned by "public"."washing_machines"."id";

CREATE UNIQUE INDEX base_user_pkey ON public.base_users USING btree (id);

CREATE UNIQUE INDEX customers_pkey ON public.customers USING btree (id);

CREATE INDEX idx_reservations_machine_lower_slot ON public.reservations USING btree (machine_id, lower(slot));

CREATE UNIQUE INDEX items_id_key ON public.items USING btree (id);

CREATE UNIQUE INDEX items_pkey ON public.items USING btree (id);

CREATE UNIQUE INDEX nabava_pkey ON public.gerba_storage USING btree (id);

CREATE UNIQUE INDEX orders_pkey ON public.transactions USING btree (id);

CREATE UNIQUE INDEX permission_types_pkey ON public.permission_types USING btree (id);

CREATE UNIQUE INDEX permissions_pkey ON public.permissions USING btree (id);

select 1; -- CREATE INDEX reservations_machine_id_slot_excl ON public.reservations USING gist (machine_id, slot);

CREATE UNIQUE INDEX reservations_pkey ON public.reservations USING btree (id);

CREATE UNIQUE INDEX residents_pkey ON public.residents USING btree (id);

CREATE UNIQUE INDEX washing_machines_name_key ON public.washing_machines USING btree (name);

CREATE UNIQUE INDEX washing_machines_pkey ON public.washing_machines USING btree (id);

alter table "public"."base_users" add constraint "base_user_pkey" PRIMARY KEY using index "base_user_pkey";

alter table "public"."customers" add constraint "customers_pkey" PRIMARY KEY using index "customers_pkey";

alter table "public"."gerba_storage" add constraint "nabava_pkey" PRIMARY KEY using index "nabava_pkey";

alter table "public"."items" add constraint "items_pkey" PRIMARY KEY using index "items_pkey";

alter table "public"."permission_types" add constraint "permission_types_pkey" PRIMARY KEY using index "permission_types_pkey";

alter table "public"."permissions" add constraint "permissions_pkey" PRIMARY KEY using index "permissions_pkey";

alter table "public"."reservations" add constraint "reservations_pkey" PRIMARY KEY using index "reservations_pkey";

alter table "public"."residents" add constraint "residents_pkey" PRIMARY KEY using index "residents_pkey";

alter table "public"."transactions" add constraint "orders_pkey" PRIMARY KEY using index "orders_pkey";

alter table "public"."washing_machines" add constraint "washing_machines_pkey" PRIMARY KEY using index "washing_machines_pkey";

alter table "public"."base_users" add constraint "base_user_auth_fkey" FOREIGN KEY (auth) REFERENCES auth.users(id) ON UPDATE CASCADE not valid;

alter table "public"."base_users" validate constraint "base_user_auth_fkey";

alter table "public"."base_users" add constraint "base_users_resident_fkey" FOREIGN KEY (resident) REFERENCES residents(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."base_users" validate constraint "base_users_resident_fkey";

alter table "public"."customers" add constraint "customers_user_link_fkey" FOREIGN KEY (user_link) REFERENCES auth.users(id) not valid;

alter table "public"."customers" validate constraint "customers_user_link_fkey";

alter table "public"."gerba_storage" add constraint "public_nabava_minister_fkey" FOREIGN KEY (minister) REFERENCES auth.users(id) not valid;

alter table "public"."gerba_storage" validate constraint "public_nabava_minister_fkey";

alter table "public"."items" add constraint "items_id_key" UNIQUE using index "items_id_key";

alter table "public"."permissions" add constraint "permissions_permission_type_fkey" FOREIGN KEY (permission_type) REFERENCES permission_types(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."permissions" validate constraint "permissions_permission_type_fkey";

alter table "public"."reservations" add constraint "reservations_machine_id_fkey" FOREIGN KEY (machine_id) REFERENCES washing_machines(id) ON DELETE CASCADE not valid;

alter table "public"."reservations" validate constraint "reservations_machine_id_fkey";

alter table "public"."reservations" add constraint "reservations_machine_id_slot_excl" EXCLUDE USING gist (machine_id WITH =, slot WITH &&);

alter table "public"."reservations" add constraint "reservations_user_id_fkey" FOREIGN KEY (user_id) REFERENCES base_users(id) not valid;

alter table "public"."reservations" validate constraint "reservations_user_id_fkey";

alter table "public"."residents" add constraint "residents_phone_number_check" CHECK ((length(phone_number) < 20)) not valid;

alter table "public"."residents" validate constraint "residents_phone_number_check";

alter table "public"."transactions" add constraint "transactions_customer_id_fkey" FOREIGN KEY (customer_id) REFERENCES base_users(id) ON UPDATE RESTRICT ON DELETE RESTRICT not valid;

alter table "public"."transactions" validate constraint "transactions_customer_id_fkey";

alter table "public"."transactions" add constraint "transactions_item_fkey" FOREIGN KEY (item) REFERENCES items(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."transactions" validate constraint "transactions_item_fkey";

alter table "public"."washing_machines" add constraint "washing_machines_name_key" UNIQUE using index "washing_machines_name_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.add_reservation_with_range(p_machine_id integer, p_slot_start timestamp with time zone, p_slot_end timestamp with time zone, p_note text DEFAULT NULL::text)
 RETURNS bigint
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    slot_start_utc TIMESTAMPTZ;
    slot_end_utc TIMESTAMPTZ;
    current_user_uuid UUID;
    current_user_id BIGINT;
    inserted_id BIGINT;
BEGIN
    -- Get the current authenticated user's UUID from Supabase Auth
    current_user_uuid := auth.uid();

    -- Resolve the bigint user_id from base_users using auth_user_id
    SELECT id INTO current_user_id
    FROM base_users
    WHERE auth = current_user_uuid;

    -- Ensure the user exists
    IF current_user_id IS NULL THEN
        RAISE EXCEPTION 'User not found in base_users table';
    END IF;

    -- Quantize start to whole hour (floor)
    slot_start_utc := date_trunc('hour', p_slot_start);

    -- Quantize end to whole hour (ceil)
    IF date_trunc('hour', p_slot_end) = p_slot_end THEN
        slot_end_utc := p_slot_end;
    ELSE
        slot_end_utc := date_trunc('hour', p_slot_end) + INTERVAL '1 hour';
    END IF;

    -- Insert reservation using the bigint user_id
    INSERT INTO reservations (machine_id, user_id, slot, note)
    VALUES (p_machine_id, current_user_id, tstzrange(slot_start_utc, slot_end_utc, '[)'), p_note)
    RETURNING id INTO inserted_id;

    RETURN inserted_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.current_user_has_permission(permission_name text)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT EXISTS (
    SELECT 1
    FROM public.permissions p
    JOIN public.permission_types pt ON pt.id = p.permission_type
    JOIN public.customers c ON c.id = p.user_id
    WHERE c.user_link = (SELECT auth.uid())
      AND pt.name = permission_name
  );
$function$
;

create or replace view "public"."everything" as  SELECT bu.id AS user_id,
    (COALESCE(NULLIF(bu.name, ''::text), ''::text) ||
        CASE
            WHEN ((bu.surname IS NOT NULL) AND (bu.surname <> ''::text)) THEN (' '::text || bu.surname)
            ELSE ''::text
        END) AS fullname,
    t.ordered_at,
    t.ordered,
    t.paid,
    i.name AS item_name,
    i.price AS item_price
   FROM ((base_users bu
     LEFT JOIN transactions t ON ((bu.id = t.customer_id)))
     LEFT JOIN items i ON ((t.item = i.id)));


create or replace view "public"."everything_sum" as  WITH customer_totals AS (
         SELECT b.id,
            b.name,
            b.surname,
            sum((i.beer_count * t.ordered)) AS total_ordered,
            sum(t.paid) AS total_paid,
            sum((i.price * (t.ordered)::numeric)) AS total_value
           FROM ((base_users b
             LEFT JOIN transactions t ON ((b.id = t.customer_id)))
             LEFT JOIN items i ON ((t.item = i.id)))
          GROUP BY b.id, b.name, b.surname
        )
 SELECT id,
    name,
    surname,
    total_ordered,
    total_paid,
    total_value,
    (total_value - total_paid) AS total_difference
   FROM customer_totals;


CREATE OR REPLACE FUNCTION public.get_reservations_for_user(p_base_user_id bigint)
 RETURNS TABLE(reservation_id bigint, machine_id integer, machine_name text, slot_start_utc timestamp with time zone, slot_end_utc timestamp with time zone, note text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        r.id AS reservation_id,
        wm.id AS machine_id,
        wm.name AS machine_name,
        lower(r.slot) AS slot_start_utc,
        upper(r.slot) AS slot_end_utc,
        r.note
    FROM reservations r
    JOIN washing_machines wm ON wm.id = r.machine_id
    WHERE r.user_id = p_base_user_id
    ORDER BY lower(r.slot) ASC;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_reservations_week(p_date timestamp with time zone)
 RETURNS TABLE(reservation_id bigint, machine_id integer, machine_name text, user_id uuid, created_at timestamp with time zone, name text, surname text, room integer, phone_number text, date_of_birth date, auth_user_id uuid, slot_start_utc timestamp without time zone, slot_end_utc timestamp without time zone, slot_index_local integer, note text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        r.id,
        r.machine_id,
        wm.name as machine_name,
        bu.auth AS user_id,
        bu.created_at,
        bu.name,
        bu.surname,
        res.room,
        res.phone_number,
        res.birth_date AS date_of_birth,
        bu.auth AS auth_user_id,
        lower(r.slot) AT TIME ZONE 'UTC' AS slot_start_utc,
        upper(r.slot) AT TIME ZONE 'UTC' AS slot_end_utc,
        ((date_part('hour', lower(r.slot) AT TIME ZONE 'Europe/Ljubljana')::int / 3) + 1) AS slot_index_local,
        r.note
    FROM reservations r
    JOIN washing_machines wm ON wm.id = r.machine_id
    LEFT JOIN base_users bu ON bu.id = r.user_id
    LEFT JOIN residents res ON bu.resident = res.id
    WHERE lower(r.slot) >= p_date
      AND lower(r.slot) < p_date + interval '7 days'
    ORDER BY lower(r.slot);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_slots_for_day(p_date timestamp with time zone)
 RETURNS TABLE(machine_id integer, machine_name text, slot_start_utc timestamp with time zone, slot_end_utc timestamp with time zone, slot_index_local integer, is_empty boolean, reservation_id bigint, user_id uuid, created_at timestamp with time zone, first_name text, surname text, room integer, phone_number text, date_of_birth date, auth_user_id uuid, note text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    WITH slot_definitions AS (
        SELECT generate_series(0, 7) AS slot_index_local
    ),
    machines AS (
        SELECT id, name FROM washing_machines
    ),
    slots AS (
        SELECT
            m.id AS machine_id,
            m.name AS machine_name,
            s.slot_index_local,
            -- keep TIMESTAMPTZ: cast the final value
            (
                date_trunc('day', p_date AT TIME ZONE 'Europe/Ljubljana')
                + (s.slot_index_local * INTERVAL '3 hours')
            ) AT TIME ZONE 'Europe/Ljubljana' AS slot_start_utc,
            (
                date_trunc('day', p_date AT TIME ZONE 'Europe/Ljubljana')
                + ((s.slot_index_local + 1) * INTERVAL '3 hours')
            ) AT TIME ZONE 'Europe/Ljubljana' AS slot_end_utc
        FROM slot_definitions s
        CROSS JOIN machines m
    )
    SELECT
        sl.machine_id,
        sl.machine_name,
        sl.slot_start_utc,
        sl.slot_end_utc,
        sl.slot_index_local + 1,
        r.id IS NULL,
        r.id,
        bu.auth AS user_id,
        bu.created_at,
        bu.name AS first_name,
        bu.surname,
        res.room,
        res.phone_number,
        res.birth_date AS date_of_birth,
        bu.auth AS auth_user_id,
        r.note
    FROM slots sl
    LEFT JOIN reservations r
           ON r.machine_id = sl.machine_id
          AND lower(r.slot) = sl.slot_start_utc
    LEFT JOIN base_users bu
           ON bu.id = r.user_id
    LEFT JOIN residents res ON bu.resident = res.id
    ORDER BY sl.machine_id, sl.slot_start_utc;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_total_summary(datefrom timestamp with time zone, dateto timestamp with time zone)
 RETURNS TABLE(total_ordered numeric, total_paid numeric, total_value numeric, total_debt numeric, total_beer_count numeric)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    WITH total_data AS (
        SELECT 
            COALESCE(SUM(t.ordered), 0::NUMERIC) AS total_ordered,
            COALESCE(SUM(t.paid), 0::NUMERIC) AS total_paid,
            COALESCE(SUM(i.price * t.ordered::NUMERIC), 0::NUMERIC) AS total_value,
            COALESCE(
                SUM(i.price * t.ordered::NUMERIC) - SUM(t.paid),
                0::NUMERIC
            ) AS total_debt,
            COALESCE(SUM(i.beer_count * t.ordered), 0::BIGINT::NUMERIC) AS total_beer_count
        FROM 
            transactions t
            LEFT JOIN items i ON t.item = i.id
        WHERE 
            t.ordered_at BETWEEN dateFrom AND dateTo
    )
    SELECT 
        total_data.total_ordered,
        total_data.total_paid,
        total_data.total_value,
        total_data.total_debt,
        total_data.total_beer_count 
    FROM 
        total_data;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_expanded(p_base_user_id bigint)
 RETURNS TABLE(base_user_id bigint, created_at timestamp with time zone, name text, surname text, room integer, phone_number text, date_of_birth date, auth_user_id uuid, auth_email text)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        bu.id AS base_user_id,
        bu.created_at,
        bu.name,
        bu.surname,
        r.room,
        r.phone_number,
        r.birth_date,
        bu.auth AS auth_user_id,
        au.email::text AS auth_email
    FROM base_users bu
    LEFT JOIN residents r ON bu.resident = r.id
    JOIN auth.users au ON au.id = bu.auth
    WHERE bu.id = p_base_user_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_expanded_from_auth()
 RETURNS TABLE(auth_user_id uuid, auth_email text, auth_created_at timestamp with time zone, base_user_id bigint, base_name text, base_surname text, base_room integer, base_phone_number text, base_data_of_birth date)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        au.id AS auth_user_id,
        au.email::text AS auth_email,
        au.created_at::timestamptz AS auth_created_at,
        bu.id AS base_user_id,
        bu.name AS base_name,
        bu.surname AS base_surname,
        r.room AS base_room,
        r.phone_number AS base_phone_number,
        r.birth_date AS base_data_of_birth
    FROM auth.users au
    JOIN base_users bu ON bu.auth = au.id
    LEFT JOIN residents r ON bu.resident = r.id
    WHERE au.id = auth.uid();
END;
$function$
;

create or replace view "public"."monthly_summary" as  WITH all_months AS (
         SELECT date_trunc('month'::text, t.ordered_at) AS month_start,
            COALESCE(sum((t.ordered * i.beer_count)), (0)::numeric) AS total_ordered,
            COALESCE(sum(t.paid), (0)::numeric) AS total_paid,
            COALESCE(sum((i.price * (t.ordered)::numeric)), (0)::numeric) AS total_value
           FROM (transactions t
             LEFT JOIN items i ON ((t.item = i.id)))
          GROUP BY (date_trunc('month'::text, t.ordered_at))
        )
 SELECT month_start,
    total_ordered,
    total_paid,
    total_value
   FROM all_months;


create or replace view "public"."named_transactions" as  WITH all_transactions AS (
         SELECT t.id,
            t.customer_id,
            t.ordered_at,
            t.ordered,
            t.paid,
            c.fullname,
            i.name AS item_name,
            i.price AS item_price,
            i.beer_count AS item_beer_count,
            (i.price * (t.ordered)::numeric) AS value,
            ((i.price * (t.ordered)::numeric) - (t.paid)::numeric) AS owed
           FROM ((transactions t
             LEFT JOIN customers c ON ((t.customer_id = c.id)))
             LEFT JOIN items i ON ((t.item = i.id)))
        )
 SELECT id,
    fullname,
    customer_id,
    ordered_at,
    ordered,
    paid,
    item_name,
    item_price,
    item_beer_count,
    value,
    owed
   FROM all_transactions;


create type "public"."reservation_info" as ("reservation_id" bigint, "user_id" uuid, "user_email" text, "note" text);

create type "public"."slot_info" as ("time_start_utc" timestamp without time zone, "time_end_utc" timestamp without time zone, "is_empty" boolean, "reservation" reservation_info);

create type "public"."machine_info" as ("id" integer, "name" text, "slots" slot_info[]);

CREATE OR REPLACE FUNCTION public.slot_range_from_date_index(p_date date, p_slot_index integer, p_tz text DEFAULT NULL::text)
 RETURNS tstzrange
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
DECLARE
    start_ts TIMESTAMP;
    start_tz TIMESTAMPTZ;
    end_tz TIMESTAMPTZ;
BEGIN
    IF p_slot_index < 1 OR p_slot_index > 6 THEN
        RAISE EXCEPTION 'slot_index must be between 1 and 6';
    END IF;

    -- compute start as date + (slot_index-1)*4 hours (timestamp without tz)
    start_ts := (p_date::timestamp + ( (p_slot_index - 1) * INTERVAL '4 hours' ));

    IF p_tz IS NULL OR length(trim(p_tz)) = 0 THEN
        -- cast to timestamptz using session timezone
        start_tz := start_ts::timestamptz;
    ELSE
        -- interpret start_ts as time in p_tz, convert to timestamptz
        -- (timestamp without tz) AT TIME ZONE zone -> timestamptz
        start_tz := start_ts AT TIME ZONE p_tz;
    END IF;

    end_tz := start_tz + INTERVAL '4 hours';

    RETURN tstzrange(start_tz, end_tz, '[)');
END;
$function$
;

create or replace view "public"."total_summary" as  WITH total_data AS (
         SELECT COALESCE(sum(t.ordered), (0)::numeric) AS total_ordered,
            COALESCE(sum(t.paid), (0)::numeric) AS total_paid,
            COALESCE(sum((i.price * (t.ordered)::numeric)), (0)::numeric) AS total_value,
            COALESCE((sum((i.price * (t.ordered)::numeric)) - sum(t.paid)), (0)::numeric) AS total_debt,
            COALESCE(sum((i.beer_count * t.ordered)), ((0)::bigint)::numeric) AS total_beer_count
           FROM (transactions t
             LEFT JOIN items i ON ((t.item = i.id)))
        )
 SELECT total_ordered,
    total_paid,
    total_value,
    total_debt,
    total_beer_count
   FROM total_data;


create or replace view "public"."weekly_summary" as  WITH all_weeks AS (
         SELECT date_trunc('week'::text, t.ordered_at) AS week_start,
            COALESCE(sum((t.ordered * i.beer_count)), (0)::numeric) AS total_ordered,
            COALESCE(sum(t.paid), (0)::numeric) AS total_paid,
            COALESCE(sum((i.price * (t.ordered)::numeric)), (0)::numeric) AS total_value
           FROM (transactions t
             LEFT JOIN items i ON ((t.item = i.id)))
          GROUP BY (date_trunc('week'::text, t.ordered_at))
        )
 SELECT week_start,
    total_ordered,
    total_paid,
    total_value
   FROM all_weeks;


grant delete on table "public"."base_users" to "anon";

grant insert on table "public"."base_users" to "anon";

grant references on table "public"."base_users" to "anon";

grant select on table "public"."base_users" to "anon";

grant trigger on table "public"."base_users" to "anon";

grant truncate on table "public"."base_users" to "anon";

grant update on table "public"."base_users" to "anon";

grant delete on table "public"."base_users" to "authenticated";

grant insert on table "public"."base_users" to "authenticated";

grant references on table "public"."base_users" to "authenticated";

grant select on table "public"."base_users" to "authenticated";

grant trigger on table "public"."base_users" to "authenticated";

grant truncate on table "public"."base_users" to "authenticated";

grant update on table "public"."base_users" to "authenticated";

grant delete on table "public"."base_users" to "service_role";

grant insert on table "public"."base_users" to "service_role";

grant references on table "public"."base_users" to "service_role";

grant select on table "public"."base_users" to "service_role";

grant trigger on table "public"."base_users" to "service_role";

grant truncate on table "public"."base_users" to "service_role";

grant update on table "public"."base_users" to "service_role";

grant delete on table "public"."customers" to "anon";

grant insert on table "public"."customers" to "anon";

grant references on table "public"."customers" to "anon";

grant select on table "public"."customers" to "anon";

grant trigger on table "public"."customers" to "anon";

grant truncate on table "public"."customers" to "anon";

grant update on table "public"."customers" to "anon";

grant delete on table "public"."customers" to "authenticated";

grant insert on table "public"."customers" to "authenticated";

grant references on table "public"."customers" to "authenticated";

grant select on table "public"."customers" to "authenticated";

grant trigger on table "public"."customers" to "authenticated";

grant truncate on table "public"."customers" to "authenticated";

grant update on table "public"."customers" to "authenticated";

grant delete on table "public"."customers" to "service_role";

grant insert on table "public"."customers" to "service_role";

grant references on table "public"."customers" to "service_role";

grant select on table "public"."customers" to "service_role";

grant trigger on table "public"."customers" to "service_role";

grant truncate on table "public"."customers" to "service_role";

grant update on table "public"."customers" to "service_role";

grant delete on table "public"."gerba_storage" to "anon";

grant insert on table "public"."gerba_storage" to "anon";

grant references on table "public"."gerba_storage" to "anon";

grant select on table "public"."gerba_storage" to "anon";

grant trigger on table "public"."gerba_storage" to "anon";

grant truncate on table "public"."gerba_storage" to "anon";

grant update on table "public"."gerba_storage" to "anon";

grant delete on table "public"."gerba_storage" to "authenticated";

grant insert on table "public"."gerba_storage" to "authenticated";

grant references on table "public"."gerba_storage" to "authenticated";

grant select on table "public"."gerba_storage" to "authenticated";

grant trigger on table "public"."gerba_storage" to "authenticated";

grant truncate on table "public"."gerba_storage" to "authenticated";

grant update on table "public"."gerba_storage" to "authenticated";

grant delete on table "public"."gerba_storage" to "service_role";

grant insert on table "public"."gerba_storage" to "service_role";

grant references on table "public"."gerba_storage" to "service_role";

grant select on table "public"."gerba_storage" to "service_role";

grant trigger on table "public"."gerba_storage" to "service_role";

grant truncate on table "public"."gerba_storage" to "service_role";

grant update on table "public"."gerba_storage" to "service_role";

grant delete on table "public"."items" to "anon";

grant insert on table "public"."items" to "anon";

grant references on table "public"."items" to "anon";

grant select on table "public"."items" to "anon";

grant trigger on table "public"."items" to "anon";

grant truncate on table "public"."items" to "anon";

grant update on table "public"."items" to "anon";

grant delete on table "public"."items" to "authenticated";

grant insert on table "public"."items" to "authenticated";

grant references on table "public"."items" to "authenticated";

grant select on table "public"."items" to "authenticated";

grant trigger on table "public"."items" to "authenticated";

grant truncate on table "public"."items" to "authenticated";

grant update on table "public"."items" to "authenticated";

grant delete on table "public"."items" to "service_role";

grant insert on table "public"."items" to "service_role";

grant references on table "public"."items" to "service_role";

grant select on table "public"."items" to "service_role";

grant trigger on table "public"."items" to "service_role";

grant truncate on table "public"."items" to "service_role";

grant update on table "public"."items" to "service_role";

grant delete on table "public"."permission_types" to "anon";

grant insert on table "public"."permission_types" to "anon";

grant references on table "public"."permission_types" to "anon";

grant select on table "public"."permission_types" to "anon";

grant trigger on table "public"."permission_types" to "anon";

grant truncate on table "public"."permission_types" to "anon";

grant update on table "public"."permission_types" to "anon";

grant delete on table "public"."permission_types" to "authenticated";

grant insert on table "public"."permission_types" to "authenticated";

grant references on table "public"."permission_types" to "authenticated";

grant select on table "public"."permission_types" to "authenticated";

grant trigger on table "public"."permission_types" to "authenticated";

grant truncate on table "public"."permission_types" to "authenticated";

grant update on table "public"."permission_types" to "authenticated";

grant delete on table "public"."permission_types" to "service_role";

grant insert on table "public"."permission_types" to "service_role";

grant references on table "public"."permission_types" to "service_role";

grant select on table "public"."permission_types" to "service_role";

grant trigger on table "public"."permission_types" to "service_role";

grant truncate on table "public"."permission_types" to "service_role";

grant update on table "public"."permission_types" to "service_role";

grant delete on table "public"."permissions" to "anon";

grant insert on table "public"."permissions" to "anon";

grant references on table "public"."permissions" to "anon";

grant select on table "public"."permissions" to "anon";

grant trigger on table "public"."permissions" to "anon";

grant truncate on table "public"."permissions" to "anon";

grant update on table "public"."permissions" to "anon";

grant delete on table "public"."permissions" to "authenticated";

grant insert on table "public"."permissions" to "authenticated";

grant references on table "public"."permissions" to "authenticated";

grant select on table "public"."permissions" to "authenticated";

grant trigger on table "public"."permissions" to "authenticated";

grant truncate on table "public"."permissions" to "authenticated";

grant update on table "public"."permissions" to "authenticated";

grant delete on table "public"."permissions" to "service_role";

grant insert on table "public"."permissions" to "service_role";

grant references on table "public"."permissions" to "service_role";

grant select on table "public"."permissions" to "service_role";

grant trigger on table "public"."permissions" to "service_role";

grant truncate on table "public"."permissions" to "service_role";

grant update on table "public"."permissions" to "service_role";

grant delete on table "public"."reservations" to "anon";

grant insert on table "public"."reservations" to "anon";

grant references on table "public"."reservations" to "anon";

grant select on table "public"."reservations" to "anon";

grant trigger on table "public"."reservations" to "anon";

grant truncate on table "public"."reservations" to "anon";

grant update on table "public"."reservations" to "anon";

grant delete on table "public"."reservations" to "authenticated";

grant insert on table "public"."reservations" to "authenticated";

grant references on table "public"."reservations" to "authenticated";

grant select on table "public"."reservations" to "authenticated";

grant trigger on table "public"."reservations" to "authenticated";

grant truncate on table "public"."reservations" to "authenticated";

grant update on table "public"."reservations" to "authenticated";

grant delete on table "public"."reservations" to "service_role";

grant insert on table "public"."reservations" to "service_role";

grant references on table "public"."reservations" to "service_role";

grant select on table "public"."reservations" to "service_role";

grant trigger on table "public"."reservations" to "service_role";

grant truncate on table "public"."reservations" to "service_role";

grant update on table "public"."reservations" to "service_role";

grant delete on table "public"."residents" to "anon";

grant insert on table "public"."residents" to "anon";

grant references on table "public"."residents" to "anon";

grant select on table "public"."residents" to "anon";

grant trigger on table "public"."residents" to "anon";

grant truncate on table "public"."residents" to "anon";

grant update on table "public"."residents" to "anon";

grant delete on table "public"."residents" to "authenticated";

grant insert on table "public"."residents" to "authenticated";

grant references on table "public"."residents" to "authenticated";

grant select on table "public"."residents" to "authenticated";

grant trigger on table "public"."residents" to "authenticated";

grant truncate on table "public"."residents" to "authenticated";

grant update on table "public"."residents" to "authenticated";

grant delete on table "public"."residents" to "service_role";

grant insert on table "public"."residents" to "service_role";

grant references on table "public"."residents" to "service_role";

grant select on table "public"."residents" to "service_role";

grant trigger on table "public"."residents" to "service_role";

grant truncate on table "public"."residents" to "service_role";

grant update on table "public"."residents" to "service_role";

grant delete on table "public"."transactions" to "anon";

grant insert on table "public"."transactions" to "anon";

grant references on table "public"."transactions" to "anon";

grant select on table "public"."transactions" to "anon";

grant trigger on table "public"."transactions" to "anon";

grant truncate on table "public"."transactions" to "anon";

grant update on table "public"."transactions" to "anon";

grant delete on table "public"."transactions" to "authenticated";

grant insert on table "public"."transactions" to "authenticated";

grant references on table "public"."transactions" to "authenticated";

grant select on table "public"."transactions" to "authenticated";

grant trigger on table "public"."transactions" to "authenticated";

grant truncate on table "public"."transactions" to "authenticated";

grant update on table "public"."transactions" to "authenticated";

grant delete on table "public"."transactions" to "service_role";

grant insert on table "public"."transactions" to "service_role";

grant references on table "public"."transactions" to "service_role";

grant select on table "public"."transactions" to "service_role";

grant trigger on table "public"."transactions" to "service_role";

grant truncate on table "public"."transactions" to "service_role";

grant update on table "public"."transactions" to "service_role";

grant delete on table "public"."washing_machines" to "anon";

grant insert on table "public"."washing_machines" to "anon";

grant references on table "public"."washing_machines" to "anon";

grant select on table "public"."washing_machines" to "anon";

grant trigger on table "public"."washing_machines" to "anon";

grant truncate on table "public"."washing_machines" to "anon";

grant update on table "public"."washing_machines" to "anon";

grant delete on table "public"."washing_machines" to "authenticated";

grant insert on table "public"."washing_machines" to "authenticated";

grant references on table "public"."washing_machines" to "authenticated";

grant select on table "public"."washing_machines" to "authenticated";

grant trigger on table "public"."washing_machines" to "authenticated";

grant truncate on table "public"."washing_machines" to "authenticated";

grant update on table "public"."washing_machines" to "authenticated";

grant delete on table "public"."washing_machines" to "service_role";

grant insert on table "public"."washing_machines" to "service_role";

grant references on table "public"."washing_machines" to "service_role";

grant select on table "public"."washing_machines" to "service_role";

grant trigger on table "public"."washing_machines" to "service_role";

grant truncate on table "public"."washing_machines" to "service_role";

grant update on table "public"."washing_machines" to "service_role";

create policy "base_users_delete_manage_users"
on "public"."base_users"
as permissive
for delete
to authenticated
using (current_user_has_permission('MANAGE_USERS'::text));


create policy "base_users_insert_enroll"
on "public"."base_users"
as permissive
for insert
to authenticated
with check (current_user_has_permission('ENROLL'::text));


create policy "base_users_select_manage_users"
on "public"."base_users"
as permissive
for select
to authenticated
using (current_user_has_permission('MANAGE_USERS'::text));


create policy "base_users_select_own"
on "public"."base_users"
as permissive
for select
to authenticated
using (((( SELECT auth.uid() AS uid) IS NOT NULL) AND (auth = ( SELECT auth.uid() AS uid))));


create policy "base_users_update_manage_users"
on "public"."base_users"
as permissive
for update
to authenticated
using (current_user_has_permission('MANAGE_USERS'::text))
with check (current_user_has_permission('MANAGE_USERS'::text));


create policy "permissions_delete_managers"
on "public"."permissions"
as permissive
for delete
to authenticated
using (current_user_has_permission('MANAGE_PERMISSIONS'::text));


create policy "permissions_insert_managers"
on "public"."permissions"
as permissive
for insert
to authenticated
with check (current_user_has_permission('MANAGE_PERMISSIONS'::text));


create policy "permissions_select_managers"
on "public"."permissions"
as permissive
for select
to authenticated
using (current_user_has_permission('MANAGE_PERMISSIONS'::text));


create policy "residents_delete_manage_users"
on "public"."residents"
as permissive
for delete
to authenticated
using (current_user_has_permission('MANAGE_USERS'::text));


create policy "residents_insert_enroll_resident"
on "public"."residents"
as permissive
for insert
to authenticated
with check (current_user_has_permission('ENROLL_RESIDENT'::text));


create policy "residents_select_own"
on "public"."residents"
as permissive
for select
to authenticated
using (((( SELECT auth.uid() AS uid) IS NOT NULL) AND (EXISTS ( SELECT 1
   FROM base_users bu
  WHERE ((bu.resident = residents.id) AND (bu.auth = ( SELECT auth.uid() AS uid)))))));


create policy "residents_update_manage_users"
on "public"."residents"
as permissive
for update
to authenticated
using (current_user_has_permission('MANAGE_USERS'::text))
with check (current_user_has_permission('MANAGE_USERS'::text));


create policy "washing_machines_select_authenticated"
on "public"."washing_machines"
as permissive
for select
to authenticated
using (true);



